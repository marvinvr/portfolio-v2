<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Solar System Model</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        #tooltip {
            position: absolute;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px;
            border-radius: 5px;
            display: none;
            pointer-events: none;
        }
        #launchRocket {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px;
            background: white;
            border: none;
            cursor: pointer;
        }
        #datePicker {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 5px;
        }
        #credit {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
        }
        #credit a {
            color: white;
            text-decoration: underline;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.167.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.167.1/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="tooltip"></div>
    <input type="date" id="datePicker">
    <button id="launchRocket">Launch Rocket</button>
    <div id="credit">by <a href="https://marvinvr.ch" target="_blank">marvinvr</a></div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;

        const tooltip = document.getElementById('tooltip');
        const launchRocketBtn = document.getElementById('launchRocket');
        const datePicker = document.getElementById('datePicker');

        const GM = 0.12;
        const homing = 0.0005; // Small homing factor
        const au_km = 149597870; // 1 AU in km
        const earth_distance_units = 110; // Model Earth distance
        const scale_km_per_unit = au_km / earth_distance_units;
        const starship_speed_km_s = 30; // Approximate average speed for Starship to Mars in km/s
        const seconds_per_day = 86400;

        // Solar system data
        const planetsData = [
            { name: 'Sun', radius: 20, distance: 0, color: 0xffff00, ring: false, speed: 0 },
            { name: 'Mercury', radius: 3, distance: 50, color: 0x808080, ring: false, speed: 0.04 },
            { name: 'Venus', radius: 5, distance: 80, color: 0xffa500, ring: false, speed: 0.035 },
            { name: 'Earth', radius: 6, distance: 110, color: 0x0000ff, ring: false, speed: 0.03 },
            { name: 'Mars', radius: 4, distance: 140, color: 0xff0000, ring: false, speed: 0.025 },
            { name: 'Jupiter', radius: 12, distance: 200, color: 0xa52a2a, ring: false, speed: 0.02 },
            { name: 'Saturn', radius: 10, distance: 260, color: 0xffd700, ring: true, speed: 0.015 },
            { name: 'Uranus', radius: 8, distance: 320, color: 0xadd8e6, ring: true, speed: 0.01 },
            { name: 'Neptune', radius: 8, distance: 380, color: 0x00008b, ring: false, speed: 0.008 }
        ];

        const planets = []; // Moving planets
        const bodies = []; // All including sun for hover
        const orbits = [];
        const asteroids = [];

        // Reference data for real positions
        const refDate = new Date('2025-07-10');
        const periods = [0, 87.969, 224.701, 365.256, 686.98, 4332.59, 10759.22, 30685.4, 60190]; // days
        const refAngles = [0, -1.9979, -0.0703, -1.2550, -2.9088, 1.6447, -0.0746, 1.0042, -0.0010];
        let angles;

        function updatePositions(selectedDate) {
            const deltaDays = (selectedDate - refDate) / (1000 * 60 * 60 * 24);
            angles = refAngles.map((ref, i) => (i === 0 ? 0 : ref + (2 * Math.PI / periods[i]) * deltaDays));

            for (let i = 0; i < planets.length; i++) {
                const data = planetsData[i + 1];
                planets[i].position.x = data.distance * Math.cos(angles[i + 1]);
                planets[i].position.z = data.distance * Math.sin(angles[i + 1]);
            }
        }

        // Add sun with accents
        const sunGeometry = new THREE.SphereGeometry(planetsData[0].radius, 32, 16);
        const sunColors = [];
        const sunPos = sunGeometry.attributes.position.array;
        for (let i = 0; i < sunPos.length; i += 3) {
            const x = sunPos[i];
            const y = sunPos[i + 1];
            const z = sunPos[i + 2];
            const noise = Math.sin(x * 2 + y) + Math.cos(z * 2 + y);
            const color = noise > 0 ? new THREE.Color('yellow') : new THREE.Color('orange');
            sunColors.push(color.r, color.g, color.b);
        }
        sunGeometry.setAttribute('color', new THREE.Float32BufferAttribute(sunColors, 3));
        const sunMaterial = new THREE.MeshBasicMaterial({ vertexColors: true });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);
        bodies.push(sun);

        // Add stars background
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
        const starsVertices = [];
        for (let i = 0; i < 5000; i++) {
            const x = THREE.MathUtils.randFloatSpread(2000);
            const y = THREE.MathUtils.randFloatSpread(2000);
            const z = THREE.MathUtils.randFloatSpread(2000);
            starsVertices.push(x, y, z);
        }
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // Add planets and orbits
        for (let i = 1; i < planetsData.length; i++) {
            const data = planetsData[i];

            // Orbit
            const curve = new THREE.EllipseCurve(0, 0, data.distance, data.distance);
            const points = curve.getPoints(100);
            const orbitGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const orbitMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 });
            const orbit = new THREE.Line(orbitGeometry, orbitMaterial);
            orbit.rotation.x = Math.PI / 2;
            scene.add(orbit);
            orbits.push(orbit);

            // Planet with accents
            const geometry = new THREE.SphereGeometry(data.radius, 32, 16);
            let material;
            if (data.name === 'Earth') {
                const colors = [];
                const pos = geometry.attributes.position.array;
                for (let j = 0; j < pos.length; j += 3) {
                    const x = pos[j];
                    const y = pos[j + 1];
                    const z = pos[j + 2];
                    const lat = Math.asin(y / data.radius);
                    const lon = Math.atan2(z, x);
                    const continentNoise = Math.sin(lon * 3) + Math.cos(lat * 5) + Math.sin((lon + lat) * 2);
                    const oceanNoise = Math.sin(x * 10 + y * 5) + Math.cos(z * 10);
                    const isLand = continentNoise > 0.5;
                    const color = isLand ? new THREE.Color('green').add(new THREE.Color(oceanNoise * 0.1, oceanNoise * 0.1, 0)) : new THREE.Color('blue');
                    colors.push(color.r, color.g, color.b);
                }
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                material = new THREE.MeshBasicMaterial({ vertexColors: true });
            } else if (data.name === 'Mars') {
                const colors = [];
                const pos = geometry.attributes.position.array;
                for (let j = 0; j < pos.length; j += 3) {
                    const x = pos[j];
                    const y = pos[j + 1];
                    const z = pos[j + 2];
                    const lat = Math.abs(y) / data.radius;
                    const craterNoise = Math.sin(x * 5 + z * 5) + Math.cos(y * 5 + z * 3);
                    const baseColor = lat > 0.8 ? new THREE.Color('white') : new THREE.Color('red');
                    const color = craterNoise > 1 ? baseColor.clone().multiplyScalar(0.8) : baseColor;
                    colors.push(color.r, color.g, color.b);
                }
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                material = new THREE.MeshBasicMaterial({ vertexColors: true });
            } else if (data.name === 'Jupiter') {
                const colors = [];
                const pos = geometry.attributes.position.array;
                for (let j = 0; j < pos.length; j += 3) {
                    const y = pos[j + 1];
                    const lat = Math.abs(y) / data.radius;
                    let colorHex;
                    if (lat > 0.8) colorHex = 0xeeeeee; // white-ish
                    else if (lat > 0.6) colorHex = 0xa52a2a; // brown
                    else if (lat > 0.4) colorHex = 0xffd700; // gold
                    else if (lat > 0.2) colorHex = 0xa52a2a;
                    else colorHex = 0xeeeeee;
                    const color = new THREE.Color(colorHex);
                    colors.push(color.r, color.g, color.b);
                }
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                material = new THREE.MeshBasicMaterial({ vertexColors: true });
            } else if (data.name === 'Saturn') {
                const colors = [];
                const pos = geometry.attributes.position.array;
                for (let j = 0; j < pos.length; j += 3) {
                    const y = pos[j + 1];
                    const lat = Math.abs(y) / data.radius;
                    let colorHex;
                    if (lat > 0.7) colorHex = 0xffd700; // gold
                    else if (lat > 0.4) colorHex = 0xdeb887; // light brown
                    else colorHex = 0xffd700;
                    const color = new THREE.Color(colorHex);
                    colors.push(color.r, color.g, color.b);
                }
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                material = new THREE.MeshBasicMaterial({ vertexColors: true });
            } else {
                material = new THREE.MeshBasicMaterial({ color: data.color });
            }
            const planet = new THREE.Mesh(geometry, material);
            scene.add(planet);
            planets.push(planet);
            bodies.push(planet);

            if (data.ring) {
                const ringGeometry = new THREE.TorusGeometry(data.radius * 1.5, data.radius * 0.2, 2, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                planet.add(ring);
            }
        }

        // Set default date to current
        const today = new Date().toISOString().split('T')[0];
        datePicker.value = today;
        updatePositions(new Date());

        datePicker.addEventListener('change', () => {
            const selectedDate = new Date(datePicker.value);
            updatePositions(selectedDate);
        });

        camera.position.z = 500;

        // Hover detection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(bodies);

            if (intersects.length > 0) {
                const intersected = intersects[0].object;
                const index = bodies.indexOf(intersected);
                tooltip.textContent = planetsData[index].name;
                tooltip.style.display = 'block';
                tooltip.style.left = `${event.clientX + 10}px`;
                tooltip.style.top = `${event.clientY + 10}px`;
            } else {
                tooltip.style.display = 'none';
            }
        }

        renderer.domElement.addEventListener('mousemove', onMouseMove);

        // Asteroid launch variables
        let holdTimeout = null;
        let showerInterval = null;
        let isShower = false;
        let launchMouse = new THREE.Vector2();

        function launchAsteroid(mx, my) {
            mouse.x = mx;
            mouse.y = my;

            raycaster.setFromCamera(mouse, camera);

            let direction = raycaster.ray.direction.clone().normalize();

            const startDistance = 600;
            const startPos = direction.clone().multiplyScalar(startDistance);

            const astGeo = new THREE.SphereGeometry(2, 16, 16);
            const astMat = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });
            const ast = new THREE.Mesh(astGeo, astMat);
            ast.position.copy(startPos);

            let dir = direction.clone().negate();
            dir.x += (Math.random() - 0.5) * 0.3;
            dir.y += (Math.random() - 0.5) * 0.3;
            dir.z += (Math.random() - 0.5) * 0.3;
            dir.normalize();

            ast.userData.velocity = dir.multiplyScalar(5);
            ast.userData.trailPositions = [];

            const trailMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
            const trailGeometry = new THREE.BufferGeometry();
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trail);

            ast.userData.trail = trail;

            scene.add(ast);
            asteroids.push(ast);
        }

        // Press and hold for shower
        renderer.domElement.addEventListener('mousedown', (event) => {
            if (event.button !== 0) return; // Left button only
            launchMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            launchMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            holdTimeout = setTimeout(() => {
                isShower = true;
                controls.enabled = false;
                showerInterval = setInterval(() => {
                    launchAsteroid(launchMouse.x, launchMouse.y);
                }, 100);
            }, 300);
        });

        renderer.domElement.addEventListener('mouseup', (event) => {
            if (event.button !== 0) return;
            if (holdTimeout) {
                clearTimeout(holdTimeout);
            }
            if (isShower) {
                clearInterval(showerInterval);
                isShower = false;
                controls.enabled = true;
            } else {
                // Short click: launch single
                launchAsteroid(launchMouse.x, launchMouse.y);
            }
        });

        // Launch rocket
        launchRocketBtn.addEventListener('click', () => {
            const earthIndex = 2; // planets[2] = Earth
            const marsIndex = 3; // planets[3] = Mars
            const earthPos = planets[earthIndex].position.clone();
            const marsData = planetsData[marsIndex + 1];
            const angleMars = angles[marsIndex + 1];
            const omegaMars = marsData.speed * 0.01;
            const rMars = marsData.distance;
            const rocketSpeed = 0.15; // Adjusted for better warping without hitting sun

            // Binary search for intercept time
            let low = 0;
            let high = 10000; // Increased for slower speed
            for (let i = 0; i < 50; i++) {
                let mid = (low + high) / 2;
                let futureAngle = angleMars + omegaMars * mid;
                let futureMars = new THREE.Vector3(
                    rMars * Math.cos(futureAngle),
                    0,
                    rMars * Math.sin(futureAngle)
                );
                let dist = futureMars.distanceTo(earthPos);
                let tNeeded = dist / rocketSpeed;
                if (tNeeded < mid) {
                    high = mid;
                } else {
                    low = mid;
                }
            }
            let t = (low + high) / 2;

            // Calculate future Mars position
            let futureAngle = angleMars + omegaMars * t;
            let futureMars = new THREE.Vector3(
                rMars * Math.cos(futureAngle),
                0,
                rMars * Math.sin(futureAngle)
            );

            // Direction and velocity
            let dir = futureMars.sub(earthPos).normalize();
            let vel = dir.multiplyScalar(rocketSpeed);

            // Create rocket as cylinder + cone
            const rocketGroup = new THREE.Group();
            const bodyGeo = new THREE.CylinderGeometry(0.8, 0.8, 4, 8);
            const bodyMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.5;
            rocketGroup.add(body);

            const noseGeo = new THREE.ConeGeometry(0.8, 1.5, 8);
            const noseMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const nose = new THREE.Mesh(noseGeo, noseMat);
            nose.position.y = 3.75;
            rocketGroup.add(nose);

            const finGeo = new THREE.BoxGeometry(0.2, 0.5, 1);
            const finMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            for (let k = 0; k < 4; k++) {
                const fin = new THREE.Mesh(finGeo, finMat);
                fin.position.set(Math.cos(k * Math.PI / 2) * 0.8, 0.25, Math.sin(k * Math.PI / 2) * 0.8);
                fin.rotation.y = k * Math.PI / 2;
                rocketGroup.add(fin);
            }

            rocketGroup.position.copy(earthPos);
            rocketGroup.userData.velocity = vel;
            rocketGroup.userData.trailPositions = [];
            rocketGroup.userData.landed = false;
            rocketGroup.userData.distance = 0;
            rocketGroup.userData.travelSteps = 0;

            // Initial orientation
            rocketGroup.lookAt(rocketGroup.position.clone().add(vel));
            rocketGroup.rotateX(Math.PI / 2); // Adjust to point nose in direction of travel

            const trailMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 });
            const trailGeometry = new THREE.BufferGeometry();
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trail);

            rocketGroup.userData.trail = trail;

            scene.add(rocketGroup);
            asteroids.push(rocketGroup);
        });

        function animate(time = 0) {
            requestAnimationFrame(animate);

            // Animate planets
            for (let i = 0; i < planets.length; i++) {
                const data = planetsData[i + 1];
                angles[i + 1] += data.speed * 0.01;
                planets[i].position.x = data.distance * Math.cos(angles[i + 1]);
                planets[i].position.z = data.distance * Math.sin(angles[i + 1]);
            }

            // Animate asteroids and rockets
            for (let i = asteroids.length - 1; i >= 0; i--) {
                const ast = asteroids[i];
                if (ast.userData.landed) {
                    ast.position.copy(planets[3].position);
                } else {
                    // Apply gravity if rocket
                    if (ast.userData.hasOwnProperty('landed')) {
                        const pos = ast.position;
                        const r = pos.length();
                        if (r > 0.0001) {
                            const a_mag = -GM / (r * r);
                            const a = pos.clone().normalize().multiplyScalar(a_mag);
                            ast.userData.velocity.add(a);
                        }

                        // Add homing correction
                        const correction = planets[3].position.clone().sub(ast.position).normalize().multiplyScalar(homing);
                        ast.userData.velocity.add(correction);

                        ast.userData.distance += ast.userData.velocity.length();
                        ast.userData.travelSteps++;
                    }

                    ast.position.add(ast.userData.velocity);

                    // Update orientation for rocket
                    if (ast.userData.hasOwnProperty('landed')) {
                        const direction = ast.userData.velocity.clone().normalize();
                        if (direction.length() > 0) {
                            ast.lookAt(ast.position.clone().add(direction));
                            ast.rotateX(Math.PI / 2); // Adjust if model is along y
                        }
                    }

                    // Check if close to Mars if rocket
                    if (ast.userData.hasOwnProperty('landed')) { // is rocket
                        const dist = ast.position.distanceTo(planets[3].position);
                        if (dist < 5) {
                            ast.userData.landed = true;
                            ast.userData.velocity.set(0, 0, 0);
                            scene.remove(ast.userData.trail);
                            ast.userData.trail = null;

                            // Show notification
                            const real_distance_km = ast.userData.distance * scale_km_per_unit;
                            const days = real_distance_km / (starship_speed_km_s * seconds_per_day);
                            const distance_km_formatted = real_distance_km.toFixed(0);
                            const days_formatted = days.toFixed(0);

                            let notif = document.createElement('div');
                            notif.style.position = 'fixed';
                            notif.style.bottom = '10px';
                            notif.style.right = '10px';
                            notif.style.background = 'rgba(0,0,0,0.7)';
                            notif.style.color = 'white';
                            notif.style.padding = '10px';
                            notif.style.borderRadius = '5px';
                            notif.textContent = `🚀 Rocket arrived! Travel time: ${days_formatted} days at Starship speed, Distance: ${distance_km_formatted} km`;
                            document.body.appendChild(notif);
                            setTimeout(() => { notif.remove(); }, 5000);
                        }
                    }
                }

                // Update trail only if not landed and trail exists
                if (!ast.userData.landed && ast.userData.trail) {
                    ast.userData.trailPositions.push(ast.position.clone());
                    if (ast.userData.trailPositions.length > 50) {
                        ast.userData.trailPositions.shift();
                    }
                    ast.userData.trail.geometry.setFromPoints(ast.userData.trailPositions);
                }

                if (ast.position.length() > 1000 && !ast.userData.landed) {
                    scene.remove(ast);
                    if (ast.userData.trail) {
                        scene.remove(ast.userData.trail);
                    }
                    asteroids.splice(i, 1);
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>